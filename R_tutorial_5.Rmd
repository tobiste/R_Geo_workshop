---
title: "Programming with R --- A Beginners’ Guide for Geoscientists"
author: "Tobias Stephan"
date: "10/02/2022"
output:
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    highlight: tango
    theme: united
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: yes
subtitle: 5 - Maps
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
gc()
```

Packages we need:
```{r packages, echo = TRUE, message = FALSE, warning = FALSE}
pacman::p_load(
  dplyr,
  squish,
  scales,

  # plotting
  ggplot2,
  scico,
  patchwork,
  ggrepel,
  ggthemes,

  # geospatial packages
  sp,
  sf,
  raster,
  rgeos,
  rgdal,
  pracma,

  # spatial interpolation
  gstat
)

# my functions and stuff for the course
source("course_stuff.R")
```

## Maps

### Seismics at BC coast

In this tutorial, we want to produce a map of the western coast of Canada and its seismicity.
First we load the earthquake table (*.csv) that I downloaded from the USGS earthquake database.

```{r data, echo=TRUE}
earthquakes <- read.csv("Data/Map/earthquakes_2000-2020.csv", sep = ",") %>%
  arrange(depth)
head(earthquakes)
```


### Basic maps
Now we start to set up a very basic map where we only show the earthquake locations. 
```{r map0, echo=TRUE}
map1 <- ggplot() + # extent of the map
  borders() + # political borders
  geom_point(
    data = earthquakes,
    aes(longitude, latitude), size = 2
  ) +
  coord_cartesian(
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  )
map1
```

`ggplot()` treats the data as any other. It does not know yet, that the data is actually geospatial.

In the geograohic coordinate system, latitudes and lLongitudes are equally spaced. We can assign this property by using `coord_equal()` instead of ` coord_cartesian()`. Here we use the same map and just add the new plot assignment, it will overwrite the previous settings for the axes.
```{r coord.equal, echo = TRUE, message = FALSE, warning = FALSE}
map1 + coord_equal(
  xlim = range(earthquakes$longitude),
  ylim = range(earthquakes$latitude)
) + # extent of the map
  labs(title = "Geographical coordinates")
```

`ggplot()` allos us to reproject our spatial data into any coordinate reference system (CRS) by using `coord_map()` instead of `coord_equal()`

```{r reproj, echo = TRUE, message = FALSE, warning = FALSE}
map1 +
  coord_equal(
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(title = "No projection") +
  map1 +
  coord_map(
    projection = "mercator",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "mercator",
    subtitle = "equally spaced straight meridians,\nconformal, straight compass courses"
  ) +
  map1 +
  coord_map(
    projection = "azequidistant",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "azequidistant",
    subtitle = "equally spaced parallels,\ntrue distances from pole"
  ) +
  map1 +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "azequalarea",
    subtitle = "equal-area"
  ) +
  map1 +
  coord_map(
    projection = "albers",
    parameters = c(50, 58.5),
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "albers",
    subtitle = "equal-area,\ntrue scale on lat0 and lat1"
  ) +
  plot_layout(guides = "collect")
```

```{r gc1, eval=TRUE, include=FALSE}
gc()
```

Let's use the equal area projection. 
In the next step, we will modify the earthquake symbols. 
We can just add some properties of the data set (columns of the data.frame) into the aesthetic (`aes()`), such as the color, the shape, the size, or the opacity (`alpha`).

```{r map2, echo=TRUE}
map2 <- ggplot(data = earthquakes) +
  borders(fill = alpha("grey", .25)) + # political borders
  geom_point(aes(longitude, latitude, color = depth, size = mag), alpha = .75) +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "Seismicity of western British Columbia",
    subtitle = "Data source: ANSS Comprehensive Earthquake Catalog",
    caption = "equal-area projection"
  ) +
  theme_bw()
map2
```

The plot above will produce some default outputs (colors). 

We can modify the colors and aesthetics by using `scale_[aesthetics]`, 

```{r map2_legend, echo = TRUE, message = FALSE, warning = FALSE}
map2.2 <- map2 +
  scale_colour_gradient(
    name = "Depth (km)",
    low = "blue",
    high = "red",
    breaks = seq(0, 30, 5)
  ) +
  scale_size_binned(name = "Magnitude")
map2.2
```

We do not have to define the color palette. `ggplot()` offers a variety of pre-installed color palettes.

```{r colors, echo = TRUE, message = FALSE, warning = FALSE}
map2.2 +
  scale_color_gradientn(
    colors = rainbow(8),
    name = "Depth (km)",
    breaks = seq(0, 30, 5)
  )
```
Many scientific journals already require (or at least recommend) to use readable colors for colour-vision deficient or colorblind people.  

The package `scico` provides a list of scientific color palettes that are

- colorblind-friendly
- perceptually uniform and ordered to represent data both fairly, without visual distortion, and intuitively, and 
- still readable when printed in black and white

```{r colorblind, echo = TRUE, message = FALSE, warning = FALSE}
map2.2 + scico::scale_color_scico(
  palette = "hawaii",
  name = "Depth (km)",
  direction = -1,
  breaks = seq(0, 30, 5)
)
```

### Import Shape-files
Now we want to add the plate boundaries to the map. The plate boundaries are stored in a ESRI shape file that can be imported using `st_read()` from the sf package.
```{r read.shp, message=FALSE, echo=TRUE}
# load shape file as 'simple feature'
plates <- sf::st_read("Data/Map/plate_boundaries.shp") # plate boundaries
sf::st_crs(plates) <- "WGS84" # set the CRS
```

There are some more additional steps requiered to add the plate boundaries to our map. This includes to convert the sf feature into a data.frame
```{r shp.prepare, message=FALSE, warning=FALSE, echo=TRUE}
plates.df <-
  sf::st_drop_geometry(plates) %>%
  mutate(id = as.character(seq_along(plates$Code)))

plates.sp <- sf::as_Spatial(plates) %>% # convert into "sp" feature
  broom::tidy() %>%
  left_join(plates.df)
```

```{r gc2, eval=TRUE, include=FALSE, echo=TRUE}
gc()
```

Now add the plate boundaries to our map:
```{r map.plate, echo=TRUE}
ggplot(data = earthquakes %>% arrange(depth)) +
  geom_path(
    data = plates.sp,
    aes(long, lat, group = group),
    lwd = 2,
    color = colorblind[7]
  ) +
  borders(fill = alpha("grey", .25)) + # political borders
  geom_point(aes(longitude, latitude, color = depth, size = mag), alpha = .75) +
  scale_color_scico(
    palette = "hawaii",
    name = "Depth (km)",
    direction = -1,
    breaks = seq(0, 30, 5)
  ) +
  scale_size_binned(name = "Magnitude") +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "Seismicity of western British Columbia",
    subtitle = "Data source: ANSS Comprehensive Earthquake Catalog",
    caption = "equal-area projection"
  ) +
  theme_bw()
```

### Create a spatial object
To create spatial objects, e.g. a point, line etc., we need to specify the coordinates and the CRS.
Create a lines object

```{r line1, echo=TRUE}
# as a matrix
line.pts <- cbind(
  lon = c(-120, -130),
  lat = c(52, 48)
)

# as a data.frame
line.df <- as.data.frame(cbind(line.pts))

# as a spatial object
line.sf <- sf::st_linestring(line.pts) %>%
  sf::st_geometry() %>%
  sf::st_set_crs(value = "WGS84")
```

Plot the new object as a profile line and add to the map:
```{r plot_line, echo=TRUE}
ggplot() +
  geom_path(
    data = plates.sp,
    aes(long, lat, group = group),
    lwd = 2,
    color = colorblind[7]
  ) +
  borders(fill = alpha("grey", .25)) +
  geom_point(
    data = earthquakes,
    aes(longitude, latitude, color = depth, size = mag),
    alpha = .75
  ) +
  scale_color_scico(
    palette = "hawaii",
    name = "Depth (km)",
    direction = -1,
    breaks = seq(0, 30, 5)
  ) +
  scale_size_binned(name = "Magnitude") +

  # adds the profile line
  geom_line(data = line.df, aes(lon, lat), lty = 2) +

  # end points
  geom_point(data = line.df, aes(lon, lat), size = 2) +

  # label the points
  geom_label_repel(data = line.df, aes(lon, lat), label = c("A", "B")) +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(
    title = "Seismicity of western British Columbia",
    subtitle = "Data source: ANSS Comprehensive Earthquake Catalog",
    caption = "equal-area projection"
  ) +

  # change to a map theme
  ggthemes::theme_map()
```

```{r gc3, eval=TRUE, include=FALSE, echo=TRUE}
gc()
```

### Save ESRI shape file
Save line into ESRI shapefile:
```{r line2, echo=FALSE, eval=FALSE, include=TRUE, echo=TRUE}
sf::st_write(line.sf, "Data/Map/my_line.shp")
```


### Import Raster
To import and handle raster datasets, we need the **raster** package.
The import is done by using `raster()`
```{r raster_load, echo=TRUE}
dem <- raster::raster("Data/Map/ETOPO_vancouver.tif")

# first glimpse
plot(dem)
```

The raster resolution, i.e. the pixel cell size can be retrieved by `res()`
```{r resolution1, echo=TRUE}
raster::res(dem)
```

The raster resolution is 0.3 x 0.3 degree.

We can decrease and increase the resolution with `aggregate()` and `disaggregate()`, respectively.
```{r resolution2, echo=TRUE}
# lower the resolution by factor 2:
dem.low <- raster::aggregate(dem, fact = 2)
raster::res(dem.low)
plot(dem.low)

# increase resolution
# raster::disaggregate(dem, fact = 2)
```


#### Crop a raster
To crop or clip a raster along a spatial feature (e.g. the extent of our earthquake dataset), we can use `crop()`:
```{r raster_crop, echo=TRUE}
crop_extent <- sf::st_bbox(c(
  xmin = min(earthquakes$longitude),
  xmax = max(earthquakes$longitude),
  ymin = min(earthquakes$latitude),
  ymax = max(earthquakes$latitude)
),
crs = sf::st_crs("WGS84")
) %>%
  sf::st_as_sfc() %>%
  sf::as_Spatial()

dem.cropped <- raster::crop(dem.low, crop_extent)
plot(dem.cropped)
plot(crop_extent, add = TRUE)
```

#### Reproject the raster
Raster data can also be transformed or reprojected into different CRSs.

To use the `projectRaster()` function, we need to define two things:

- the object we want to reproject and
- the CRS that we want to reproject it to.

The syntax is `raster::projectRaster(RasterObject, crs = CRSToReprojectTo)`

Here, we want to transform the raster (in WGS84) into an equal area projection (aea). 
```{r aea, echo=TRUE}
aea <- "+proj=aea +lat_0=45 +lon_0=-126 +lat_1=50 +lat_2=58.5 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs"

dem.aea <- raster::projectRaster(dem.cropped, crs = raster::crs(aea))
plot(dem.aea)
```

> When we reproject a raster, we move it from one “grid” to another. Thus, we are modifying the data! Keep this in mind as we work with raster data.


#### Save raster
```{r write_raster, eval=FALSE, include=TRUE, echo=TRUE}
raster::writeRaster(dem.aea, "Data/Map/dem_cropped.tif", overwrite = TRUE)
```

Next, we will convert the dataset to a dataframe for plotting with ggplot.
```{r raster.df, echo=TRUE}
dem.df <- as(dem.cropped, "SpatialPixelsDataFrame") %>%
  as.data.frame()
colnames(dem.df) <- c("elevation", "lon", "lat")
```

Thereby, we can also do some statistics on the raster's "z" value (here the elevation):
```{r raster_stats, warning=FALSE, message=FALSE, echo=TRUE}
# Stats numbers
dem.df$elevation %>% summary()

# Histogram
hist(dem.df$elevation)
```



#### Plot the raster
To plot a raster we can use `geom_raster()` (if all raster pixels are squares) or `geom_tile()`. 
Since we transformed the raster dataset, the pixel cells are not equally spaced anymore,. Thus, we use `geom_tile()` that allows distorted pixels.

Additionally we will add the city of Vancouver to our map
```{r city, echo=TRUE}
vancouver <- data.frame(city = 'Vancouver', lat = 49.3, lon = -123.1) 
```

Final plot:
```{r plot_raster, echo=TRUE}
map2 <- ggplot() +
  
  # add the raster with coloring (CPU intensive!!!)
  geom_tile(data = dem.df, aes(x = lon, y = lat, fill = elevation)) +
  
  # the raster will cover the plot's grid lines, i.e. the latitude and longitudes. We need to add them
  geom_hline(yintercept = seq(42, 54, 2),
             lwd = .1,
             color = "grey") +
  geom_vline(xintercept = seq(-140, 120, 5),
             lwd = .1,
             color = "grey") +
  geom_path(
    data = plates.sp,
    aes(long, lat, group = group),
    lwd = 2,
    color = colorblind[7]
  ) +
  geom_point(data = earthquakes,
             aes(longitude, latitude, color = depth, size = mag),
             alpha = .75) +
  geom_path(data = line.df, aes(lon, lat), lty = 2) +
  geom_point(data = line.df, aes(lon, lat), size = 2) +
  geom_label_repel(data = line.df, aes(lon, lat), label = c("B", "A")) +
  
  # city vancouver
  geom_point(
    data = vancouver,
    aes(lon, lat),
    color = " black",
    fill = ' white',
    shape = 21,
    size = 3
  ) +
  ggrepel::geom_text_repel(
    data = vancouver,
    aes(lon, lat, label = city),
    color = 'white',
    bg.color = 'black',
    bg.r = .15
  ) +
  
  
  scale_color_scico(
    palette = "hawaii",
    name = "Depth (km)",
    direction = -1,
    breaks = seq(0, 30, 5)
  ) +
  scale_size_binned(name = "Magnitude") +
  
  # colorblind color palette for topography
  scale_fill_scico(
    palette = "oleron",
    name = "Topography (m a.s.l.)",
    # legend title
    limits = c(-max(dem.df$elevation), max(dem.df$elevation)),
    #
    oob = scales::squish,
    #
    breaks = seq(-5000, 5000, 1000)
  ) + # format legend labels
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) + # extent of the map
  labs(title = "Seismicity of western British Columbia",
       subtitle = "Data source: ANSS Comprehensive Earthquake Catalog") +
  theme_map()

map2
```

#### Hillshade
To create a DEM with a hillshade background, we use the functions `terrain()` and `hillshade()` from the *raster* package:
```{r hillshade, echo=TRUE}
terr <- raster::terrain(dem.aea, c("slope", "aspect"))
hill <- raster::hillShade(terr[["slope"]], terr[["aspect"]])

RStoolbox::ggR(hill) +
  RStoolbox::ggR(dem.aea, geom_raster = TRUE, ggLayer = TRUE, alpha = 0.5) +
  scale_fill_scico(
    palette = "oleron",
    name = "Topography (m a.s.l.)",
    limits = c(-max(dem.df$elevation), max(dem.df$elevation)),
    oob = scales::squish,
    breaks = seq(-5000, 5000, 1000)
  ) +
  theme_void()
```

>Unfortunately, the `RStoolbox::ggR()` cannot be combined with `coord_map()`. It requires `coord_equal()`.


### Elevation profile (Swath)
Swath profiles are used to condense topographic information from a rectangular area (swath) to an elevation profile. 

Technically, they are not so simple to create ([see here for more details](https://sites.google.com/site/sorsbysj/geospatial-processing/geospatial-analyses/swath-profiles). 

Thus, the calculation will be CPU intensive, in particular for large and high resolution raster data! 
Our example data set should be doable on most computers... (I hope).


`swathR` calculates the elevation data in our swath. To define the swath we have to define `k` -- the number of lines parallel to our profile line ("line.pts"), `dist` -- the distance of the lines to our profile line, and the coordinate reference system -- `crs`.

```{r swath, echo=TRUE, message=FALSE, warning=FALSE}
# extracts the swath profile and some statistics
# WARNING CPU-intensive
swath.list <- swathR(
  coords = line.pts,
  raster = dem.cropped,
  crs = "+proj=longlat +ellps=WGS84 +no_defs",
  dist = .2,
  k = 1
)
```

The function returns a list of the lines coordinates, some statistics, and the elevation data along the lines. I coded a function `swathR_profile`  that extracts the swath profile (i.e. the elevation data along the center line, the minimum and maximum elevation within the swath) from this list. 

```{r extract_swath, warning=FALSE, message=FALSE, echo=TRUE}
swath.profile <- swath_profile(swath.list)
```

To plot the swath with `ggplot`, we can use the `geom_ribbon()` option and define the min and max values for the elevation:

```{r plot_swath1, echo=TRUE}
ggplot(swath.profile, aes(distance, elevation)) +
  coord_cartesian(expand = FALSE) +

  # add a horizontal aline to show the sea level
  geom_hline(
    yintercept = 0,
    lty = 2,
    alpha = .25
  ) +

  # swath
  geom_ribbon(aes(
    ymin = min,
    ymax = max
  ),
  fill = "grey"
  ) +

  # elevtion along the center line
  geom_line() +
  labs(title = "Swath profile", x = "Distance (km)", y = "Elevation (m)") +
  theme_bw()
```

Because our input data is in the geographical coordinate system, the distances are given in degrees. 
You can use my function `haversine()` to get the distance between two locations on earth:
```{r orthodrome, echo=TRUE}
distance.km <- greatcircle_distance(line.pts[1, ], line.pts[2, ])
```

Next, we scale the original distance values (in degree) to values ranging from 0 to the just claculated distance in km:
```{r swath.resc, echo=TRUE}
swath.profile$distance.km <- scales::rescale(swath.profile$distance, to = c(0, distance.km))
```

Now we can set up the profile plot ...
```{r swath2, echo=TRUE}
swath.plot <-
  ggplot(swath.profile, aes(distance.km, elevation)) +
  coord_cartesian(expand = FALSE) +
  geom_hline(
    yintercept = 0,
    lty = 2,
    alpha = .25
  ) +
  geom_ribbon(aes(
    ymin = min,
    ymax = max
  ),
  fill = "grey"
  ) +
  geom_line() +
  labs(title = "Swath profile", x = "Distance (km)", y = "Elevation (m)") +
  theme_bw()
```

... and combine it together with our map
```{r combine_plots, echo=TRUE}
map.combo <-
  map2 /
  (swath.plot + scale_y_reverse()) +
  plot_layout(heights = c(3, 1), guides = "collect")
map.combo
```

To save a plot, we can use `ggsave()` by giving the file path and the output size. It automatically identifies the file format from your file name.

### Save a map
```{r save_map, echo=FALSE, eval=FALSE, include=TRUE, echo=TRUE}
ggplot2::ggsave(map.combo, filename = "Data/DEM/my_map.pdf", width = 11, height = 8.5, scale = 0.5)
```


### Spatial interpolation

A "heat map" refers to a spatially interpolated value. 
In our example we want to interpolate the magnitude of the eartquakes for the entire area in derive a somewhat "seismic hazard map".

In order to perform a (geo)spatial interpolation, we need to transform our objects into spatial objects:
```{r eq.sp, echo=TRUE}
earthquakes.geo <- earthquakes
coordinates(earthquakes.geo) <- ~ longitude + latitude
sp::proj4string(earthquakes.geo) <-
  sp::CRS("+proj=longlat +ellps=WGS84 +no_defs")
```


```{r, eval=FALSE, include=FALSE, echo=TRUE}
earthquakes.aea <- sp::spTransform(earthquakes.geo, sp::CRS(aea))
```

Next we need to create the interpolation grid where we want to interpolate onto.
```{r grid, echo=TRUE}
# define the raster's bounding box
extent <- sp::bbox(earthquakes.geo)

# raster cell sice
spacing <- 0.5 # size of squares, in units of the CRS, i.e. degree for WGS84

grid <- expand.grid(x = seq(from = extent[1, 1], to = extent[1, 2], by = spacing), y = seq(from = extent[2, 1], to = extent[2, 2], by = spacing))
coordinates(grid) <- ~ x + y
proj4string(grid) <- sp::CRS("+proj=longlat +ellps=WGS84 +no_defs")
gridded(grid) <- TRUE
```


#### Inverse distance weigthing

Now we have set up our points and a grid to interpolate onto, we are ready carry out some interpolation. The first method we will try is inverse distance weighting (IDW) as this will not require any special modelling of spatial relationships.

To generate a surface using inverse distance weighting, use the IDW function in gstat. Check the help file for IDW -- `?idw` -- for information about what this formula is doing.

```{r idw, echo=TRUE}
idw.res <- gstat::idw(formula = mag ~ 1, newdata = grid, locations = earthquakes.geo) %>%
  as.data.frame()
names(idw.res)[1:3] <- c("lon", "lat", "var.pred")
```

Now we have our IDW output we can plot it using ggplot2. 
```{r idw.map, message=FALSE, warning=FALSE, echo=TRUE}
map3 <- ggplot() +
  
  # add the raster with coloring (CPU intensive!!!)
  geom_tile(data = idw.res, aes(lon, lat, fill = var.pred)) +
  geom_path(
    data = plates.sp,
    aes(long, lat, group = group),
    lwd = 2,
    color = colorblind[7]
  ) +
  borders() +
  geom_point(
    data = earthquakes,
    aes(longitude, latitude),
    color = "white",
    shape = "o",
  ) +
  geom_point(
    data = vancouver,
    aes(lon, lat),
    color = " black",
    fill = ' white',
    shape = 21,
    size = 3
  ) +
  ggrepel::geom_text_repel(
    data = vancouver,
    aes(lon, lat, label = city),
    color = 'white',
    bg.color = 'black',
    bg.r = .15
  ) +
  # colorblind-friendly color
  scale_fill_scico(palette = "tokyo", name = "Magnitude (interpolated)") +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) +
  labs(title = "Seismicity of western British Columbia",
       subtitle = "Data source: ANSS Comprehensive Earthquake Catalog") +
  theme_map()
map3
```

Save the map into png
```{r, echo=FALSE, eval=FALSE, include=TRUE, echo=TRUE}
ggsave(map3, filename = "Data/DEM/my_heatmap.png", width = 11, height = 8.5)
```


#### Kriging

Kriging is a little more involved than IDW as it requires the construction of a semivariogram model to describe the spatial autocorrelation pattern for your particular variable.

```{r variocloud, echo=TRUE}
variogcloud <- gstat::variogram(mag ~ 1, locations = earthquakes.geo, data = earthquakes.geo, cloud = TRUE)
plot(variogcloud)
```

The values in the cloud can be binned into lags with and plotted with a very similar function
```{r semivariog, echo=TRUE}
semivariog <- gstat::variogram(mag ~ 1, locations = earthquakes.geo, data = earthquakes.geo)
plot(semivariog)
semivariog
```

From the empirical semivariogram plot and the information contained in the `semivariog`` *gstat* object, we can estimate the sill, range and nugget to use in our model semivariogram.

- In this case, the **range** (the point on the distance axis where the semivariogram starts to level off) is around the value of the last lag -- 380.53028	-- so we’ll use Range = 380
- The **Sill** (the point on the y axis where the semivariogram starts to level off) is around 0.25
- The **nugget** looks to be around 0.20 (so the partial sill is around 0.2).

Using this information we’ll generate a model semivariogram using the `vgm()` function in *gstat*.


```{r vgm, echo=TRUE}
model.variog <- gstat::vgm(psill = 0.25, model = "Exp", nugget = 0.2, range = 380)
```

We can now fit this model to a sample variogram to see how well it fits and plot it
```{r fit.variogram, echo=TRUE}
fit.variog <- gstat::fit.variogram(semivariog, model.variog)
plot(semivariog, fit.variog)
```

Use the `krige()` function in gstat along with the model semivariogram just generated to generate an ordinary/simple Kriged surface -- again, check ` ?krige` to see what the various options in the function are.
```{r kriging, echo=TRUE}
krige.res <- gstat::krige(formula = mag ~ 1, locations = earthquakes.geo, newdata = grid, model = model.variog) %>%
  as.data.frame()
names(krige.res)[1:3] <- c("lon", "lat", "var.pred")
```

Generate a plot of the kriged surface in ggplot2 in a similar way to before
```{r krige.plot, echo=TRUE}
ggplot() +
  
  # add the raster with coloring (CPU intensive!!!)
  geom_tile(data = krige.res, aes(lon, lat, fill = var.pred)) +
  geom_path(
    data = plates.sp,
    aes(long, lat, group = group),
    lwd = 2,
    color = colorblind[7]
  ) +
  borders() +
  geom_point(
    data = earthquakes,
    aes(longitude, latitude),
    color = "white",
    shape = "o",
  ) +
  geom_point(
    data = vancouver,
    aes(lon, lat),
    color = " black",
    fill = ' white',
    shape = 21,
    size = 3
  ) +
  ggrepel::geom_text_repel(
    data = vancouver,
    aes(lon, lat, label = city),
    color = 'white',
    bg.color = 'black',
    bg.r = .15
  ) +
  # colorblind-friendly color
  scale_fill_scico(palette = "tokyo", name = "Magnitude (interpolated)") +
  coord_map(
    projection = "azequalarea",
    # the projection
    xlim = range(earthquakes$longitude),
    ylim = range(earthquakes$latitude)
  ) +
  labs(title = "Seismicity of western British Columbia",
       subtitle = "Data source: ANSS Comprehensive Earthquake Catalog") +
  theme_map()
```

This completes your very short guide to creating spatial surfaces in R.

***

## Useful resources

- Raster plotting: https://erinbecker.github.io/r-raster-vector-geospatial/02-raster-plot/index.html
- Crop a raster: https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/crop-raster-data-in-r/
- Raster reprojection: https://datacarpentry.org/r-raster-vector-geospatial/03-raster-reproject-in-r/
- Spatial interpolation with R: https://rspatial.org/raster/analysis/4-interpolation.html
- Kriging with R: https://rstudio-pubs-static.s3.amazonaws.com/46259_d328295794034414944deea60552a942.html
- Swath profile: https://jjvhab.github.io/swathR/
- "Beautify" a map : https://timogrossenbacher.ch/2016/12/beautiful-thematic-maps-with-ggplot2-only/

```{r gc4, include=FALSE}
gc(verbose = FALSE)
# styler:::style_active_file()
# lintr::lint("R_tutorial_5.Rmd")
```

***

[Content](.\R_tutorial_main.html) | [previous course: Geochronology](.\R_tutorial_4.html)
