---
title: "Programming with R --- A Beginners’ Guide for Geoscientists"
subtitle: "4 - Geo-/Thermochronology"
author: "Tobias Stephan"
date: "10/02/2022"
output: 
  html_document:
    theme: "united"
    highlight: "tango"
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Geo-/Thermochronology

Packages that we will need:
```{r packages, echo = TRUE, message = FALSE, warning = FALSE}
pacman::p_load(
  # Geo-Thermochronology packages
  IsoplotR,
  provenance,

  # plotting
  ggplot2,
  scico, # colorblind palettes for continuous data
  patchwork, # multi-plot arrangements

  # data handling
  tidyr,
  dplyr,

  # cluster analysis
  cluster,
  factoextra
)

# my functions and stuff for the course
source("course_stuff.R")
```

### U-Pb
Load example data:
```{r load, echo=TRUE}
data.upb <- examples$UPb # example data from the IsoplotR package
head(data.upb$x)
```

#### Common Pb correction

`Pb0corr()` applies a common-Pb correction to a U-Pb dataset using either the Stacey-Kramers mantle evolution model (`option = 3`), isochron regression (`option = 2`), or any nominal inital Pb isotope composition (`option = 1`).
```{r pb, echo=TRUE}
# ?Pb0corr()
data.upb.cor <- IsoplotR::Pb0corr(data.upb, option = 3)
head(data.upb.cor$x)
```


Calculate the individual ages of the individual aliquots:
```{r ages.upb, echo=TRUE}
# age per each U-Pb analysis:
# ?IsoplotR::age()
tUPb <- IsoplotR::age(data.upb.cor, type = 1) %>% as.data.frame()
head(tUPb)
```

#### Concordia diagram

Wetherill -– ${}^{206}Pb/{}^{238}U$ vs. ${}^{207}Pb/{}^{235}U$
```{r concordia1, echo=TRUE}
# ?IsoplotR::concordia()
IsoplotR::concordia(data.upb.cor, type = 1, ellipse.fill = alpha(colorblind[3], .5), concordia.col = colorblind[2])
```

Tera-Wasserburg -– ${}^{207}Pb/{}^{206}Pb$ vs. ${}^{238}U/{}^{206}Pb$
```{r concordia2, echo=TRUE}
IsoplotR::concordia(data.upb.cor, type = 2, ellipse.fill = alpha(colorblind[3], .5), concordia.col = colorblind[2])
```

The concordia age:
```{r concordia.age, echo=TRUE}
tconc <- IsoplotR::age(data.upb.cor, type = 2)
tconc
```

The result returns a list with the following values:

- `x`: a named vector with the (weighted mean) U-Pb composition
- `cov`:  the covariance matrix of the (weighted mean) U-Pb composition
- `mswd`: a vector with three items (equivalence, concordance and combined) containing the MSWD (Mean of the Squared Weighted Deviates, a.k.a the reduced Chi-squared statistic) of isotopic equivalence, age concordance and combined goodness of fit, respectively.
- `p.value`: a vector with three items (equivalence, concordance and combined) containing the p-value of the Chi-square test for isotopic equivalence, age concordance and combined goodness of fit, respectively.
- `df`:  a three-element vector with the number of degrees of freedom used for the mswd calculation.
- `age`:  a 4-element vector with:
  - `t`: the concordia age (in Ma)
  - `s[t]`: the estimated uncertainty of `t`
  - `ci[t]`: the *100(1-$\alpha$)*\% confidence interval of `t` for the appropriate degrees of freedom
  - `disp[t]`: the studentised *100(1-$\alpha$)*\% confidence interval for `t` augmented by $\sqrt{\text{mswd}}$ to account for overdispersed datasets.


#### Age spectrum (histrogram and density)
```{r upb.spectrum, echo=TRUE}
# get the optimal bandwidth using the diffusion 
# algorithm of Zdravko Botev (2011)
n <-
  provenance::botev(tUPb$t.68) 
ggplot(tUPb) +
  theme_minimal() + # minimal design
  coord_cartesian(expand = FALSE) + # set the range of the x axis
  labs(
    x = "Age (Ma)",
    caption = paste(
      "Kernel bandwidth: ",
      round(n, 1),
      "\nConcordia age: ",
      round(tconc$age[1], 2),
      " \u00B1 ",
      round(tconc$age[2], 2),
      "Ma"
    )
  ) + # axis label
  geom_histogram(
    # histogram
    aes(t.68, y = ..density..),
    color = "white",
    fill = "grey",
    alpha = .5,
    binwidth = n
  ) +
  geom_density(
    aes(t.68),
    kernel = "gaussian",
    fill = NA,
    color = colorblind[3],
    bw = n
  ) +
  geom_vline(xintercept = tconc$age[1], lty = 2)
```

#### Finite mixture modelling of geochronological dataset
Discrete mixture modelling algorithms of Galbraith and Laslett (1993) by using `peakfit()`.

`peakfit(x, k = 1)`

with

- `x` is the age dataset
- `k`	is the number of discrete age components to be sought. Setting this parameter to `'auto'` automatically selects the optimal number of components (up to a maximum of 5) using the Bayes Information Criterion (BIC).


```{r peak.fit.upb, echo=TRUE}
# ?IsoplotR::peakfit()
IsoplotR::peakfit(data.upb.cor, k = "auto")
```


### Detritals
Load some example data. The data is from a Geochron.org query. I wrote a  function  `read_geochron()` that reads the Geochron.org export into the R file, so that you don't have to do any table manipulation anymore.

```{r dz_load, echo=TRUE}
data <- read_geochron("Data/Geochron_sample_download_UPb.xls")
isotopes <- data$isotopes
meta <- data$meta
```

#### Preferred age
The U-Pb system has the big advantage that you can measure 2-3 independent "clocks", i.e. ${}^{206}\text{Pb}/{}^{238}\text{U}$, ${}^{207}\text{Pb}/{}^{235}\text{U}$,  and ${}^{206}\text{Pb}/{}^{207}\text{Pb}$. These three isotopic ratios are used to deduce the concordance of the age, i.e. the should be identical if the decay system was closed or undisturbed. In reality, noise (measurement) and bias (Pb-loss due to, e.g., metamorphism) can result in discordant ages.  

Using ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ ages to estimate discordance of Phanerozoic zircons may result in apparent discordance as for geologically young samples the intersection between the discordia reflecting the ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ age and the concordia has a very flat angle.
Even a small error in the ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ ratio has a major effect on the apparent ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ age (e.g. Mattinson, 1987). 
Because of the shape of the concordia, which flattens for older ages, the intersection of the ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ discordia and the concordia is better defined for older ages. 
Thus, the ${}^{206}\text{Pb}/{}^{238}\text{U}$ age is preferred for Phanerozoic and Neoproterozoic zircons and the ${}^{206}\text{Pb}/{}^{207}\text{Pb}$ age for zircons older than 1000 Ma.

```{r pref.age, echo=TRUE}
data.dz <- left_join(isotopes, meta, by = "Sample_ID") %>%
  mutate(
    conc = ifelse(
      t.Pb207Pb206 > 1000,
      t.Pb206U238 / t.Pb207Pb206,
      t.Pb206U238 / t.Pb207U235
    ),
    t = ifelse(t.Pb207Pb206 > 1000, t.Pb207Pb206, t.Pb206U238),
    st = ifelse(t.Pb207Pb206 > 1000, st.Pb207Pb206, st.Pb206U238)
  ) %>%
  filter(conc >= 0.85 & conc <= 1.05) # concordance filter
```

#### Histograms and kernel density distribution

The detrital age spectrum of a sample is usually shown by histograms and density distribution. 
Histograms are intuitive, whereas density distributions are not. Kernel Density Estimation are preferred over Probability Density Plots (Vermeesch 2012)
```{r kde.dz0, echo=TRUE}
dz.plot <- ggplot(data.dz) +
  theme_minimal() + # minimal design
  coord_cartesian(xlim = c(0, 4500), expand = FALSE) + # set the range of the x axis
  labs(x = "Age (Ma)") + # axis label
  geom_vline(
    xintercept = 1000, # add a vertical line at 1000 Ma
    lty = 2,
    color = "grey"
  )

dz.plot +
  geom_density( # density
    aes(t),
    kernel = "gaussian",
    alpha = .25,
    bw = 75
  )
```

This gives us a density distribution of **all** samples. If we want to plot the age spectra for each sample we can indicate this by defining the color within the aesthetics `aes()`: 

```{r kde.dz1, echo=TRUE}
dz.plot +
  geom_density( # density
    aes(t, color = Sample_ID),
    kernel = "gaussian",
    alpha = .25,
    bw = 75
  )
```

Because we have a high number of samples in our dataset, this becomes quite messy. Instead we can have a density plot per sample by 
using `facet_wrap()`:

```{r kde.dz2, echo=TRUE, warning=FALSE, message=FALSE}
dz.plot + geom_density( # density
  aes(t),
  kernel = "gaussian",
  fill = colorblind[3],
  alpha = .25,
  bw = n
) +
  geom_histogram( # histogram
    aes(t, y = ..density..),
    color = "white",
    fill = "grey",
    alpha = .5,
    binwidth = n
  ) +
  geom_density(
    aes(t),
    kernel = "gaussian",
    fill = NA,
    color = colorblind[3],
    bw = n
  ) +
  facet_wrap(~Sample_ID, # one plot per Sample_ID
    # ncol = 1,
    scales = "free_y"
  )
```

#### Cumulative distributions
Another way to visualize age apectra is the cumulative distribution. 
```{r cad.dz, echo=TRUE}
dz.plot +
  stat_ecdf(aes(t, color = Sample_ID))
```


#### Multidimensional scaling
If you have multiple features for each observation (row) in a dataset and would like to reduce the number of features in the data so as to visualize which observations are similar, Multi-Dimensional Scaling (MDS) will help.

MDS serves as a ‘map’ in which similar samples cluster closely together and dissimilar samples plot far apart. In the context of detrital geochronology, the dissimilarity between samples is given by the statistical distance between age distributions.

There are many ways to define this statistical distance. `IsoplotR` uses the Kolmogorov-Smirnov (KS) statistic due to its simplicity and the fact that it behaves like a true distance in the mathematical sense of the word (Vermeesch, 2013). The KS-distance is given by the maximum vertical distance between two cad step functions. Thus, the KS-distance takes on values between zero (perfect match between two age distributions) and one (no overlap between two distributions). Calculating the KS-distance between samples two at a time populates a symmetric dissimilarity matrix with positive values and a zero diagonal.

```{r mds0, echo=TRUE, message=FALSE, warning=FALSE}
data.dz2 <- geochron_to_dz(data.dz) #  my function. converts the Geochron table into dataset suitable for IsoplotR

# ?IsoplotR::mds()
dz.mds <- IsoplotR::mds(data.dz2, plot = FALSE)
```

The function `mds()` by the `IsoplotR` packages produces a `list` that contains the dissimilarity matrix (`diss`) and the MDS configuration coordinates (`points`).

The dissimilarity matrix can be shown by
```{r diss, echo=FALSE, include=TRUE}
dz.mds$diss
```

The MDS configuration can be shown by
```{r mds1, echo=TRUE}
head(dz.mds$points) # head() shows only the first 6 rows of a table
```

To plot the MDS result, i.e. the "map" of dissimilarities, we use the points object from the list
```{r mds2, echo=TRUE}
dz.mds.df <- data.frame(Sample_ID = rownames(dz.mds$points), X = dz.mds$points[, 1], Y = dz.mds$points[, 2]) %>%
  left_join(meta) # convert to a data.frame and join with the meta data

ggplot(dz.mds.df) +
  labs(title = "Multidimensional Scaling", subtitle = "Dissimilarity of the detrital age spectra", x = "DIM 1", y = "DIM 2") +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Stratigraphic_Formation_Name), show.legend = FALSE) + # color code the points by their stratigraphic formation
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Stratigraphic_Formation_Name)) +
  scale_color_manual(values = colorblind)
```

In the plot above, similar samples plot close together, whereas samples with contrasting detrital age spectra plot far apart.

The plot above is color coded by the Stratigraphic Formation. You can also use different meta information to explore the provenance
```{r mds3, echo=TRUE}
ggplot(dz.mds.df) +
  labs(title = "Multidimensional Scaling", x = "DIM 1", y = "DIM 2") +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Latitude), show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Latitude)) +
  scico::scale_color_scico()
```
#### Cluster the dissimilarity matrix

##### Hierarchical agglomerative clustering 
```{r cluster, echo=TRUE}
dz.hclust <- hclust(dz.mds$diss)
plot(dz.hclust)
```

##### Estimate number of Clusters
We are going to use PAM (Partitioning Around Medoids) algorithm to cluster the data and this requires us to specify how many clusters the dataset has so the next thing to do is to estimate this.


- The *silhouette coefficient* estimates the average distance between clusters. The silhouette plot shows the silhouette co efficient over values of k ranging from 1 to 10. This plot shows the highest average silhouette co-efficient occurring when k=2.

- The *gap statistic* compares intra-cluster variation for different values of k with expected intra-cluster variation under null distribution. Ideally we should be choosing the value of k which maximizes the gap statistic however in real world datasets where clusters are not so well defined it may be more parsimonious to choose the k value to be the one where the rate of increase of the statistic begins to slow down (i.e. value lowest value of k that is greater than or equal to the value of k+1 minus the standard error).

```{r nclust, echo=TRUE, warning=FALSE, message=FALSE}
factoextra::fviz_nbclust(x = dz.mds$points, diss = dz.mds$diss, FUNcluster = cluster::pam, method = "silhouette") + theme_classic()
factoextra::fviz_nbclust(x = dz.mds$points, diss = dz.mds$diss, FUNcluster = cluster::pam, method = "gap_stat") + theme_classic()
```

##### Cluster the data:
```{r clustering, echo=TRUE}
pam.res2 <- cluster::pam(dz.mds$diss, 2)
```


##### Cluster Validation

The last part of the analysis is to validate the clusters found.

Silhouette coefficient measures how similar an object i is to the other objects in its own cluster versus those in its neighbor cluster. Values close to 1 indicate the object is well clustered.

```{r clust, echo=TRUE, warning=FALSE, message=FALSE}
factoextra::fviz_silhouette(pam.res2, palette = colorblind, ggtheme = theme_classic())
```

Our 2-cluster solution gives an average silhouette coefficient of 0.47. One of the objects in cluster 1 has a negative silhouette coefficient indicating it may be in the wrong cluster.

```{r mds_cluster, echo=TRUE, warning=FALSE, message=FALSE}
cluster.df <- data.frame(Sample_ID = names(pam.res2$clustering), Cluster = pam.res2$clustering)
dz.mds.df <- left_join(dz.mds.df, cluster.df)

ggplot(dz.mds.df) +
  labs(title = "Multidimensional Scaling", x = "DIM 1", y = "DIM 2") +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Cluster), show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Cluster))
```


### Thermochron
#### Fission track data 

```{r ft, echo=TRUE}
data.ft <- read_geochron(path = "Data/Geochron_sample_download_AFT.xlsx", method = "Fission Track")
data.ft <- list(
  format = 1,
  zeta = c(as.numeric(data.ft$meta$Zeta_Factor), as.numeric(data.ft$meta$Zeta_Factor_Error_1s)),
  rhoD = c(as.numeric(data.ft$meta$Rho_d), as.numeric(data.ft$meta$Rho_d) * as.numeric(data.ft$meta$`Rho_d_%_Relative Error`) / 100),
  x = cbind(Ns = data.ft$tracks$Ns, Ni = data.ft$tracks$Ni)
)
class(data.ft) <- "fissiontracks"
# data.ft <- examples$FT1
```

```{r thermo0, echo=TRUE}
# counts
head(data.ft$x)

# Zeta value
data.ft$zeta

# rhoD
data.ft$rhoD
```

 `data.ft` has class `"fissiontracks"` and `central=FALSE`, `age()` returns a table of fission track ages and standard errors:
```{r age.ft, echo=TRUE}
data.ft.age <- IsoplotR::age(data.ft, central = FALSE) %>% as.data.frame()
head(data.ft.age)
```

The central age, i.e. the geometric mean composition of a continuous mixture of fission track (or U-Th-He data) and the corresponding age and fitting parameters can be calculated through:
```{r central.ft, echo=TRUE}
# age(data.ft, central = TRUE) # identical to central()
IsoplotR::central(data.ft)
```
The return value is a list containing the following items:

- `age` gives the central age (`t`), the standard error of t (`s[t]`),  and the width of a *100(1-$\alpha$)\%* confidence interval for t (`ci[t]`). 
- `disp` is a a three-element vector with the overdispersion (standard deviation) of the excess scatter, and the upper and lower half-widths of its *100(1-$\alpha$)\%* confidence interval.
- `mswd` is the reduced Chi-square statistic of data concordance, i.e. *mswd=$\chi$^2^/`df`*, where X^2^ is a Chi-square statistic of the EDM data or ages
- `df` is the degrees of freedom (*n-2*)
- `p.value` is the p-value of a Chi-square test with `df` degrees of freedom


Plotting the histogram and density of the age distribution:
```{r hist.ft, echo=TRUE}
n <- provenance::botev(data.ft.age$t) # get the optimal bandwidth using the diffusion algorithm of Zdravko Botev (2011)

ggplot(data.ft.age) +
  theme_minimal() + # minimal design
  coord_cartesian(expand = FALSE) + # set the range of the x axis
  labs(x = "Age (Ma)", caption = paste("Kernel bandwidth :", round(n, 1))) + # axis label
  geom_histogram( # histogram
    aes(t, y = ..density..),
    color = "white",
    fill = "grey",
    alpha = .5,
    binwidth = n
  ) +
  geom_density(
    aes(t),
    kernel = "gaussian",
    fill = NA,
    color = colorblind[3],
    bw = n
  ) +
  geom_vline(xintercept = IsoplotR::central(data.ft.age)$age[1], lty = 2)
```


#### Radial plot
The radial plot (*Galbraith, 1988, 1990*) is a graphical device that was specifically designed to display heteroscedastic data.

These dates can be more easily visualized by drawing a radial scale at some convenient distance from the origin and annotating it with labelled ticks at the appropriate angles. While the angular position of each data point represents the date, its horizontal distance from the origin is proportional to the precision. Imprecise measurements plot on the left hand side of the radial plot, whereas precise age determinations are found further towards the right. Thus, radial plots allow the observer to assess both the magnitude and the precision of quantitative data in one glance.

```{r radial, echo=TRUE}
# ?IsoplotR::radialplot()
IsoplotR::radialplot(data.ft, bg = colorblind[3], alpha = .8)
```

The plot also gives the return values from the `central()`function (see above).

#### Finite mixture modelling of geochronological dataset
For fission track data, the default input values are:

`peakfit(x, k = 1, exterr = TRUE, sigdig = 2, log = TRUE, alpha = 0.05)`

with

- `x` is the age dataset
- `k`	is the number of discrete age components to be sought. Setting this parameter to `'auto'` automatically selects the optimal number of components (up to a maximum of 5) using the Bayes Information Criterion (BIC).
- `exterr`:  propagate the external sources of uncertainty into the component age errors?
- `sigdig`: number of significant digits to be used for any legend in which the peak fitting results are to be displayed.
- `log`: take the logs of the data before applying the mixture model?
- `alpha`: cutoff value for confidence intervals

```{r peakfit.ft, echo=TRUE}
IsoplotR::peakfit(data.ft, k = "auto")
```



#### U-Th-He Data

```{r he_load, echo=TRUE}
data.uthhe <- examples$UThHe
head(data.uthhe)
```

We can use the same functions as for the fission track data. `IsoplotR` will identify the class UThHe class and changes the default values for the functions automatically.

```{r age.he, echo=TRUE}
data.uthhe.ages <- IsoplotR::age(data.uthhe, central = FALSE) %>% as.data.frame()
head(data.uthhe.ages)
```

The central age, i.e. the geometric mean composition of a continuous mixture of fission track (or U-Th-He data) and the corresponding age and fitting parameters can be calculated through:
```{r central.he, echo=TRUE}
# age(data.ft, central = TRUE) # identical to central()
IsoplotR::central(data.uthhe)
```
##### Finite mixture modelling of geochronological dataset

The default values are:
`peakfit(x, k = 1, sigdig = 2, log = TRUE, alpha = 0.05)`

with

- `x` is the age dataset
- `k`	is the number of discrete age components to be sought. Setting this parameter to `'auto'` automatically selects the optimal number of components (up to a maximum of 5) using the Bayes Information Criterion (BIC).
- `log`: take the logs of the data before applying the mixture model?
- `alpha`: cutoff value for confidence intervals
	

```{r peakfit, echo=TRUE}
# IsoplotR::peakfit()
IsoplotR::peakfit(data.uthhe, k = "auto")
```

it returns the following:

- `peaks`: a 3 x k matrix with the following rows:
  - `t`: the ages of the `k` peaks
  - `s[t]`: the estimated uncertainties of `t`
  - `ci[t]`: the widths of approximate 100(1-α)\% confidence intervals for `t`
- `props`: a 2xk matrix with the following rows:
  - `p`: the proportions of the k peaks
  - `s[p]`: the estimated uncertainties (standard errors) of p
- `L`: the log-likelihood of the fit
- `legend`: a vector of text expressions to be used in a figure legend


Plotting the histogram and density of the age distribution:

```{r hist.he, echo=TRUE}
n <- provenance::botev(data.uthhe.ages$t) # get the optimal bandwidth using the diffusion algorithm of Zdravko Botev (2011)

ggplot(data.uthhe.ages) +
  theme_minimal() + # minimal design
  coord_cartesian(expand = FALSE) + # set the range of the x axis
  labs(x = "Age (Ma)", caption = paste("Kernel bandwidth :", round(n, 2))) + # axis label
  geom_histogram( # histogram
    aes(t, y = ..density..),
    color = "white",
    fill = "grey",
    alpha = .5,
    binwidth = n
  ) +
  geom_density(
    aes(t),
    kernel = "gaussian",
    fill = NA,
    color = colorblind[3],
    bw = n
  ) +
  geom_vline(xintercept = IsoplotR::central(data.uthhe)$age[1], lty = 2)
```

#### Visualise U-Th-He data on a logratio plot or ternary diagram: the helioplot
Plot U-Th(-Sm)-He data on a *(log[He/Th] vs. log[U/He])* logratio plot or *U-Th-He ternary diagram*.

```{r helop, echo=TRUE}
# ?IsoplotR::helioplot()

# bivariate log[He/Th] vs. log[U/He] diagram
IsoplotR::helioplot(
  data.uthhe,
  logratio = TRUE,
  contour.col = c("white", colorblind[7]),
  ellipse.fill = alpha(colorblind[4], .5)
)

# U-Th-He ternary diagram
IsoplotR::helioplot(
  data.uthhe,
  logratio = FALSE,
  contour.col = c("white", colorblind[7]),
  ellipse.fill = alpha(colorblind[4], .5)
)
```


### Doube-dating
```{r dd, echo=TRUE}
dunn.meta <- read_excel("Data/dunn2017.xlsx", sheet = "meta") %>%
  tidyr::separate(col = Age.range, into = c("DA.min", "DA.max"), sep = "–", remove = FALSE, convert = TRUE)
dunn.zrn <- read_excel("Data/dunn2017.xlsx", sheet = "zrn")
dunn <- left_join(dunn.meta, dunn.zrn)
head(dunn)
```

```{r double_xy, echo=TRUE, warning=FALSE, message=FALSE}
plotxy <- ggplot(dunn, aes(x = Z.UPb.Age, y = Z.FT.Age, color = Z.Signal)) +
  theme_bw() +
  labs(x = "U-Pb age (Ma)", y = "FT age (Ma)") +
  scale_color_manual(name = "Signal", values = colorblind) +
  coord_cartesian(xlim = c(0, 3000), ylim = c(0, 800)) +
  geom_abline(slope = 1) +
  geom_errorbar(aes(
    ymin = Z.FT.Age - Z.FT.1s_err,
    ymax = Z.FT.Age + Z.FT.1s_err
  ), alpha = .25) +
  geom_errorbarh(aes(
    xmin = Z.UPb.Age - Z.UPb.2s_err / 2,
    xmax = Z.UPb.Age + Z.UPb.2s_err / 2
  ), alpha = .25) +
  geom_point(alpha = .5)
```

```{r double_den, echo=TRUE, warning=FALSE, message=FALSE}
plot.ft <- ggplot(dunn, aes(Z.FT.Age, fill = Z.Signal)) +
  theme_bw() +
  scale_fill_manual(name = "Signal", values = colorblind) +
  coord_flip(xlim = c(0, 800)) +
  geom_density(alpha = .5, show.legend = FALSE) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

plot.upb <- ggplot(dunn, aes(Z.UPb.Age, fill = Z.Signal)) +
  theme_bw() +
  scale_fill_manual(name = "Signal", values = colorblind) +
  coord_cartesian(xlim = c(0, 3000)) +
  geom_density(alpha = .5, show.legend = FALSE) +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```

#### Composite plot
To combine and arrange several plots into one figure, the package *patchwork* provides simple syntax: we just add the plots with `+`: 
```{r double, echo=TRUE, warning=FALSE, message=FALSE}
# equire(patchwork) # multi-plot arrangements
plot.upb + plot_spacer() + plotxy + plot.ft +
  plot_layout(guides = "collect", ncol = 2, widths = c(3, 1), heights = c(2, 3)) +
  plot_annotation(
    title = "Double dating plot",
    subtitle = "Mineral: zircon",
    caption = "Data from Dunn et al. 2017"
  )
```

Notice that `plot_spacer()` adds a blank space.
`plot_layout()` specifies some arrangement options, such as the number of columns (`ncol`), the relative heights and weights of the rows and columns. `guides = "collect"` brings all of the individual legends of each plot together

#### Lag-time diagram
```{r lag, warning=FALSE, message=FALSE, echo=TRUE}
ggplot(dunn %>% filter(DA > 0.3), aes(x = Z.FT.Age, y = DA, color = Sample)) +
  geom_abline(slope = -1, intercept = seq(0, 300, 5), color = "gray") +
  geom_errorbarh(aes(xmin = Z.FT.Age - Z.FT.1s_err, xmax = Z.FT.Age + Z.FT.1s_err), alpha = .2) +
  geom_errorbar(aes(ymin = DA.min, ymax = DA.max), alpha = .2) +
  geom_point(aes(shape = Z.Signal), alpha = 1) +
  scale_x_continuous(breaks = seq(0, 100, 10), position = "top") +
  scale_y_continuous(breaks = seq(0, 10, 1), trans = "reverse") +
  coord_cartesian(xlim = c(0, 100), ylim = c(0, 10), expand = F, clip = "on") +
  scale_color_manual(values = colorblind) +
  labs(title = "Lag time diagram: Zircon", x = "Zircon FT age (Ma)", y = "Depositional Age (Ma)") +
  theme_classic()
```

***

## Useful resources

IsoplotR

- Vermeesch, P. (2018). IsoplotR: A free and open toolbox for geochronology. Geoscience Frontiers, 9(5), 1479–1493. https://doi.org/10.1016/j.gsf.2018.04.001


Statistics for geochronology

- Vermeesch, P. (2012). On the visualisation of detrital age distributions. Chemical Geology, 312–313, 190–194. https://doi.org/10.1016/j.chemgeo.2012.04.021
- Vermeesch, P. (2013). Multi-sample comparison of detrital age distributions. Chemical Geology, 341, 140–146. https://doi.org/10.1016/j.chemgeo.2013.01.010
- Vermeesch, P. (2017). Statistics for LA-ICP-MS based fission track dating. Chemical Geology, 456, 19–27. https://doi.org/https://doi.org/10.1016/j.chemgeo.2017.03.002
- Vermeesch, P. (2019). Statistics for Fission-Track Thermochronology. In M. G. Malusà & P. G. Fitzgerald (Eds.), Fission-Track Thermochronology and its Application to Geology (pp. 109–122). Cham: Springer Textbooks in Earth Sciences, Geography and Environment. https://doi.org/10.1007/978-3-319-89421-8_6

Cluster analysis with R

- https://rstudio-pubs-static.s3.amazonaws.com/375287_5021917f670c435bb0458af333716136.html


```{r gc, include=FALSE}
gc(verbose = FALSE)
#styler:::style_active_file()
#lintr::lint("R_tutorial_4.Rmd")
```


***

[Content](.\R_tutorial_main.html) | [previous course: Statistics](.\R_tutorial_3.html) | [next course: Maps](.\R_tutorial_5.html)
