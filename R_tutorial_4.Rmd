---
title: "Programming with R --- A Beginnersâ€™ Guide for Geoscientists"
subtitle: "3 - Geo-/Thermochronology"
author: "Tobias Stephan"
date: "25/01/2022"
output: 
  html_document:
    theme: "united"
    highlight: "tango"
    toc: true
    toc_depth: 3
    toc_float: 
      collapsed: false
      smooth_scroll: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Geo-/Thermochronology
```{r load, echo = TRUE, message = FALSE, warning = FALSE}
require(IsoplotR)
require(ggplot2) 
require(scico) # colorblind palettes for continuous data
source("course_stuff.R")
```

### U-Pb

```{r upb_data, echo=TRUE}
source("course_stuff.R")
data <- read_geochron("Geochron_sample_download.xls")
isotopes <- data$isotopes
meta <- data$meta

samples <- left_join(isotopes, meta, by = "Sample_ID")
sample1 <- samples %>% filter(Sample_ID == "Whitehorse Formation")
```


```{r, echo=TRUE}
#data.upb <- examples$UPb
data.upb <- sample1
```

#### Concordia diagram


### Detritals
```{r dz_load}
#data.dz <- examples$DZ
data.dz  <- samples

data.dz <-
  data.dz %>% mutate(
    conc = ifelse(
      t.Pb206U238 > 1000,
      t.Pb206U238 / t.Pb207Pb206,
      t.Pb206U238 / t.Pb207U235
    ),
    t = ifelse(t.Pb206U238 > 1000, t.Pb207Pb206, t.Pb206U238),
    st = ifelse(t.Pb206U238 > 1000, st.Pb207Pb206, st.Pb206U238)
  ) %>%
  filter(conc >= 0.85 & conc <= 1.05)
```

#### Histograms and kernel density distribution

```{r kde.dz0, echo=TRUE}
dz.plot <- ggplot(data.dz) +
  theme_minimal() + # minimal design
  coord_cartesian(xlim = c(0, 4500), expand = FALSE) + # set the range of the x axis
  labs(x = 'Age (Ma)') + # axis label
  geom_vline(xintercept = 1000, # add a vertical line at 1000 Ma
             lty = 2,
             color = 'grey') 

dz.plot +
  geom_density( # density 
    aes(t),
    kernel = "gaussian",
    alpha = .25,
    bw = 75
  ) 
```
This gives us a density distribution of **all** samples. If we want to plot the age spectra for each sample we can indicate this by defining the color within the aesthetics `aes()`: 

```{r kde.dz1, echo=TRUE}
dz.plot +
  geom_density( # density 
    aes(t, color = Sample_ID),
    kernel = "gaussian",
    alpha = .25,
    bw = 75
  ) 
```
Because we have a high number of samples in our dataset, this becomes quite messy. Instead we can have a density plot per sample by 
using `facet_wrap()`:

```{r kde.dz2, echo=TRUE, warning=FALSE, message=FALSE}
dz.plot + geom_density( # density 
    aes(t),
    kernel = "gaussian",
    fill = colorblind[3],
    alpha = .25,
    bw = n
  ) +
  geom_histogram( # histogram
    aes(t, y = ..density..),
    color = 'white',
    fill = 'grey',
    alpha = .5,
    binwidth = n
  ) +
  geom_density(
    aes(t),
    kernel = "gaussian",
    fill = NA,
    color = colorblind[3],
    bw = n
  ) +
  facet_wrap( ~ Sample_ID, # one plot per Sample_ID
              #ncol = 1,
              scales = "free_y") 
```

#### Cumulative distributions
Another way to visualize age apectra is the cumulative distribution. 
```{r cad.dz, echo=TRUE}
dz.plot +
  stat_ecdf(aes(t, color = Sample_ID)) 
```


#### Multidimensional scaling
```{r mds, echo=TRUE, message=FALSE, warning=FALSE}
data.dz2 <- geochron_to_dz(data.dz)
dz.mds <- IsoplotR::mds(data.dz2, plot = FALSE)
```

plot
```{r mds2, echo=TRUE}
dz.mds.df <- data.frame(Sample_ID = rownames(dz.mds$points),  X = dz.mds$points[,1], Y = dz.mds$points[,2]) %>%
  left_join(meta)


ggplot(dz.mds.df) +
  labs(title = 'Multidimensional Scaling', x = 'DIM 1', y = 'DIM 2') +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Stratigraphic_Formation_Name), show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Stratigraphic_Formation_Name))
```

or use different meta information to explore the provenance
```{r mds3, echo=TRUE}
ggplot(dz.mds.df) +
  labs(title = 'Multidimensional Scaling', x = 'DIM 1', y = 'DIM 2') +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Latitude), show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Latitude)) +
  scico::scale_color_scico()
```
#### Cluster the dissimilarity matrix

```{r}
require(cluster)
require(factoextra)
```


##### Hierarchical agglomerative clustering 
```{r cluster}
dz.hclust <- hclust(dz.mds$diss)
plot(dz.hclust)
```
##### Estimate number of Clusters
We are going to use PAM (Partitioning Around Medoids) algorithm to cluster the data and this requires us to specify how many clusters the dataset has so the next thing to do is to estimate this.


- The *silhouette coefficient* estimates the average distance between clusters. The silhouette plot shows the silhouette co efficient over values of k ranging from 1 to 10. This plot shows the highest average silhouette co-efficient occurring when k=2.

- The *gap statistic* compares intra-cluster variation for different values of k with expected intra-cluster variation under null distribution. Ideally we should be choosing the value of k which maximizes the gap statistic however in real world datasets where clusters are not so well defined it may be more parsimonious to choose the k value to be the one where the rate of increase of the statistic begins to slow down (i.e. value lowest value of k that is greater than or equal to the value of k+1 minus the standard error).

```{r nclust, echo=TRUE, warning=FALSE, message=FALSE}
factoextra::fviz_nbclust(x=dz.mds$points, diss=dz.mds$diss, FUNcluster=cluster::pam, method = "silhouette")+ theme_classic()
factoextra::fviz_nbclust(x=dz.mds$points, diss=dz.mds$diss, FUNcluster=cluster::pam, method = "gap_stat")+ theme_classic()
```
##### Cluster the data:
```{r}
pam.res2 <- pam(dz.mds$diss, 2)
```


##### Cluster Validation

The last part of the analysis is to validate the clusters found.

Silhouette coefficient measures how similar an object i is to the other objects in its own cluster versus those in its neighbor cluster. Values close to 1 indicate the object is well clustered.

```{r clust, echo=TRUE, warning=FALSE, message=FALSE}
factoextra::fviz_silhouette(pam.res2, palette = "jco", ggtheme = theme_classic())
```
Our 2-cluster solution gives an average silhouette coefficient of 0.47. One of the objects in cluster 1 has a negative silhouette coefficient indicating it may be in the wrong cluster.

```{r mds_cluster, echo=TRUE, warning=FALSE, message=FALSE}
cluster.df <- data.frame(Sample_ID = names(pam.res2$clustering), Cluster = pam.res2$clustering)
dz.mds.df <- left_join(dz.mds.df, cluster.df)

ggplot(dz.mds.df) +
  labs(title = 'Multidimensional Scaling', x = 'DIM 1', y = 'DIM 2') +
  theme_bw() +
  coord_fixed() +
  geom_point(aes(X, Y, color = Cluster), show.legend = FALSE) +
  ggrepel::geom_text_repel(aes(X, Y, label = Sample_ID, color = Cluster))
```



### Thermochron

```{r thermo0, echo=TRUE}
data.ft <- examples$FT1
```

#### Radial plot
```{r radial, echo=TRUE}
radialplot(data.ft, bg = colorblind[3], alpha =.8)
```




## Maps

```{r map1, echo = TRUE, message = FALSE, warning = FALSE}
require(ggplot2)
require(scico)

ggplot(data = meta) +
  coord_map(projection = "azequalarea", xlim = range(meta$Longitude), ylim = range(meta$Latitude)) +
  borders() +
  geom_point(aes(Longitude, Latitude, color = Min_Age_Ma), size = 2) + 
  scale_color_scico(palette = 'batlow')
```
